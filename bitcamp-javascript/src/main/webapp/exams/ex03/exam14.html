<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ex03</title>
</head>
<body>
<h1>함수 - 에로우(arrow) 함수를 리턴하기</h1>
<script>
"use strict"
// arrow function이나 익명 함수나 같다.
//
function closureMaker(fnType, count) { // 잊지말라! 파라미터도 로컬 변수이다.
	switch (fnType) {
	case "sum":
		return () => {
		// 이렇게 클로저를 정의하는 순간 클로저가 사용하는 바깥 함수의 로컬 변수 count는
		// 클로저가 관리하는 별도의 메모리에 복제된다.
		// 따라서 바깥 함수의 실행이 끝나 그 로컬 변수가 사라지더라도
		// 클로저는 복제된 변수를 계속 사용할 수 있다.
		    var sum = 0;    
			for (var i = 1; i <= count; i++) {
				sum += i;
			}
			console.log("합계 =", sum);
		};
	case "factorial":
        return () => {
	        var sum = 1;
	        for (var i = 1; i <= count; i++) {
	            sum *= i;
	        }
	        console.log("팩토리얼 =", sum);
        };
    default:
    	return () => {
    	   console.log("해당 연산을 지원하지 않습니다.");
    	};
	}
}

var fn1 = closureMaker("sum", 10);
var fn2 = closureMaker("sum", 100);

fn1();
fn2();

</script>
</body>
</html>